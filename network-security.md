# Network Security

## <mark style="color:blue;">Passive Reconnaissance</mark>

In passive reconnaissance, you rely on publicly available knowledge. It is the knowledge that you can access from publicly available resources without directly engaging with the target. Think of it like you are looking at target territory from afar without stepping foot on that territory.

Three main tools will be covered:

<mark style="color:yellow;">whois</mark> to query WHOIS servers&#x20;

<mark style="color:yellow;">nslookup</mark> to query DNS servers&#x20;

<mark style="color:yellow;">dig</mark> to query DNS servers

We use whois to query WHOIS records, while we use nslookup and dig to query DNS database records. These are all publicly available records and hence do not alert the target.

Two online tools will also be covered

<mark style="color:yellow;">DNSDumpter</mark>

<mark style="color:yellow;">Shodan.io</mark>

These two online services allow us to collect information about our target without directly connecting to it.



#### <mark style="color:red;">Whois</mark>

A request and response protocol that follows the RFC 3912 specification. A WHOIS server listens on TCP port 43 for incoming requests. The domain registrar is responsible for maintaining the WHOIS records for the domain names it is leasing. The WHOIS server replies with various information related to the domain requested.&#x20;

To use the command use the syntax below where DOMAIN\_NAME is the domain about which you are trying to get more information.&#x20;

```
whois DOMAIN_NAME
```



#### <mark style="color:red;">Nslookup</mark>

Use nslookup to find the IP address of a domain name.

```
nslookup DOMAIN_NAME
```

Or, more generally, you can use <mark style="color:yellow;">`nslookup OPTIONS DOMAIN_NAME SERVER`</mark>. These three main parameters are:

<mark style="color:yellow;">OPTIONS</mark> contains the query type as shown in the table below. For instance, you can use A for IPv4 addresses and AAAA for IPv6 addresses.

<mark style="color:yellow;">DOMAIN\_NAME</mark> is the domain name you are looking up.&#x20;

<mark style="color:yellow;">SERVER</mark> is the DNS server that you want to query. You can choose any local or public DNS server to query. Cloudflare offers 1.1.1.1 and 1.0.0.1, Google offers 8.8.8.8 and 8.8.4.4, and Quad9 offers 9.9.9.9 and 149.112.112.112. There are many more public DNS servers that you can choose from if you want alternatives to your ISP’s DNS servers.

| Query Type | Results            |
| ---------- | ------------------ |
| A          | IPv4 Addresses     |
| AA         | IPv6 Addresses     |
| CNAME      | Canonical Name     |
| MX         | Mail Servers       |
| SOA        | Start of Authority |
| TXT        | TXT Records        |



<mark style="color:red;">**Dig**</mark>

For more advanced DNS queries and additional functionality, you can use dig, the acronym for <mark style="color:yellow;">“Domain Information Groper”</mark>. Let’s use dig to look up the MX records and compare them to nslookup. We can use dig `DOMAIN_NAME`, but to specify the record type, we would use dig `DOMAIN_NAME TYPE`. Optionally, we can select the server we want to query using `dig @SERVER DOMAIN_NAME TYPE`.

<mark style="color:yellow;">SERVER</mark> is the DNS server that you want to query.&#x20;

<mark style="color:yellow;">DOMAIN\_NAME</mark> is the domain name you are looking up.&#x20;

<mark style="color:yellow;">TYPE</mark> contains the DNS record type, as shown in the table provided earlier.



<mark style="color:red;">**DNSDumpster**</mark>

DNS lookup tools, such as nslookup and dig, cannot find subdomains on their own. The domain you are inspecting might include a different subdomain that can reveal much information about the target.



<mark style="color:red;">**Shodan.io**</mark>

When you are tasked to run a penetration test against specific targets, as part of the passive reconnaissance phase, a service like Shodan.io can be helpful to learn various pieces of information about the client’s network, without actively connecting to it.





<mark style="color:red;">SUMMARY</mark>

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

## <mark style="color:blue;">Active Reconnaissance</mark>

Active reconnaissance cannot be achieved so discreetly. It requires direct engagement with the target. Think of it like you check the locks on the doors and windows, among other potential entry points.

Examples of active reconnaissance activities include:

* Connecting to one of the company servers such as HTTP, FTP, and SMTP.
* Calling the company in an attempt to get information (social engineering).
* Entering company premises pretending to be a repairman.

<mark style="color:yellow;">Essential tools</mark> for active reconnaissance include:

* <mark style="color:yellow;">ping</mark> - ping is a command that sends an ICMP Echo packet to a remote system. If the remote system is online, and the ping packet was correctly routed and not blocked by any firewall, the remote system should send back an ICMP Echo Reply. Similarly, the ping reply should reach the first system if appropriately routed and not blocked by any firewall.



* <mark style="color:yellow;">traceroute</mark> - the traceroute command traces the route taken by the packets from your system to another host. The purpose of a traceroute is to find the IP addresses of the routers or hops that a packet traverses as it goes from your system to a target host. This command also reveals the number of routers between the two systems. It is helpful as it indicates the number of hops (routers) between your system and the target host. However, note that the route taken by the packets might change as many routers use dynamic routing protocols that adapt to network changes.



* <mark style="color:yellow;">telnet</mark> - The default port used by telnet is 23. From a security perspective, telnet sends all the data, including usernames and passwords, in cleartext. Sending in cleartext makes it easy for anyone, who has access to the communication channel, to steal the login credentials. The secure alternative is SSH (Secure SHell) protocol. **** However, the telnet client, with its simplicity, can be used for other purposes. Knowing that telnet client relies on the TCP protocol, you can use Telnet to connect to any service and grab its banner. Using `telnet IP_ADDRESS PORT`, you can connect to any service running on TCP and even exchange a few messages unless it uses encryption.

Let’s say we want to discover more information about a web server, listening on port 80. We connect to the server at port 80, and then we communicate using the HTTP protocol. You don’t need to dive into the HTTP protocol; you just need to issue GET / HTTP/1.1. To specify something other than the default index page, you can issue GET /page.html HTTP/1.1, which will request page.html. We also specified to the remote web server that we want to use HTTP version 1.1 for communication. To get a valid response, instead of an error, you need to input some value for the host host: example and hit enter twice. Executing these steps will provide the requested index page.

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption><p>The VM IP was 10.10.53.170 for this example, change accordingly</p></figcaption></figure>

<mark style="color:yellow;">Netcat</mark>

Netcat supports both TCP and UDP protocols. It can function as a client that connects to a listening port; alternatively, it can act as a server that listens on a port of your choice. Hence, it is a convenient tool that you can use as a simple client or server over TCP or UDP. **** Below is an example of how you might use netcat to target a specific ip and port.

<figure><img src=".gitbook/assets/image (2) (2).png" alt=""><figcaption></figcaption></figure>



On the transport level, the browser connects to:

* <mark style="color:yellow;">TCP port 80 by default when the website is accessed over HTTP</mark>&#x20;
* <mark style="color:yellow;">TCP port 443 by default when the website is accessed over HTTPS</mark>

The table below summarizes the key commands outlined in the active reconnaissance module

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

## <mark style="color:blue;">Nmap Live Host Discovery</mark>

When we want to target a network, we want to find an efficient tool to help us handle repetitive tasks and answer the following questions:

* Which systems are up?
* &#x20;What services are running on these systems?

Nmap has the ability to do answer both of these questions. The first will be discussed here, the second further below.&#x20;



<mark style="color:red;">**Subnets**</mark>

As part of active reconnaissance, we want to discover more information about a group of hosts or about a subnet. If you are connected to the same subnet, you would expect your scanner to rely on ARP (Address Resolution Protocol) queries to discover live hosts. An ARP query aims to get the hardware address (MAC address) so that communication over the link-layer becomes possible; however, we can use this to infer that the host is online.

If you are in Network A, you can use ARP only to discover the devices within that subnet (xxx.xxx.xxx.0/24). Suppose you are connected to a subnet different from the subnet of the target system(s). In that case, all packets generated by your scanner will be routed via the default gateway (router) to reach the systems on another subnet; however, the ARP queries won’t be routed and hence cannot cross the subnet router. ARP is a link-layer protocol, and ARP packets are bound to their subnet.



<mark style="color:red;">**Enumerating Targets**</mark>

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

<mark style="color:red;">**Discovering Live Hosts**</mark>

We will leverage the protocols to discover the live hosts. Starting from bottom to top, we can use:

* ARP from Link Layer&#x20;
* ICMP from Network Layer&#x20;
* TCP from Transport Layer&#x20;
* UDP from Transport Layer

ARP has one purpose: sending a frame to the broadcast address on the network segment and asking the computer with a specific IP address to respond by providing its MAC (hardware) address.

ICMP has many types. ICMP ping uses Type 8 (Echo) and Type 0 (Echo Reply).

Although TCP and UDP are transport layers, for network scanning purposes, a scanner can send a specially-crafted packet to common TCP or UDP ports to check whether the target will respond. This method is efficient, especially when ICMP Echo is blocked.



<mark style="color:red;">**Nmap Host Discovery Using ARP**</mark>

When no host discovery options are provided, Nmap follows the following approaches to discover live hosts:

* When a privileged user tries to scan targets on a local network (Ethernet), Nmap uses ARP requests. A privileged user is root or a user who belongs to sudoers and can run sudo.
* When a privileged user tries to scan targets outside the local network, Nmap uses ICMP echo requests, TCP ACK (Acknowledge) to port 80, TCP SYN (Synchronize) to port 443, and ICMP timestamp request.&#x20;
* When an unprivileged user tries to scan targets outside the local network, Nmap resorts to a TCP 3-way handshake by sending SYN packets to ports 80 and 443.



The tool "arp-scan" provides many options to customize your scan. One popular choice is `arp-scan --localnet` or simply `arp-scan -l`. This command will send ARP queries to all valid IP addresses on your local networks. Moreover, if your system has more than one interface and you are interested in discovering the live hosts on one of them, you can specify the interface using -I. For instance, `sudo arp-scan -I eth0 -l` will send ARP queries for all valid IP addresses on the eth0 interface.



<mark style="color:red;">**Nmap Host Discovery Using ICMP**</mark>

To use ICMP echo request to discover live hosts, add the option `-PE`. (Remember to add `-sn` if you don’t want to follow that with a port scan.)

Use a command like `nmap -PE -sn MACHINE_IP/24`  to scan a targets subnet. We would expect all live hosts to repy. However, remember that firewalls block ICMP. <mark style="color:yellow;">This scan would show the MAC addresses of any machines that are on the same subnet</mark> as our scanning machine.&#x20;

Because ICMP echo requests tend to be blocked, you might also consider ICMP Timestamp or ICMP Address Mask requests to tell if a system is online. Nmap uses timestamp request (ICMP Type 13) and checks whether it will get a Timestamp reply (ICMP Type 14). Adding the -PP option tells Nmap to use ICMP timestamp requests.

Similarly, Nmap uses address mask queries (ICMP Type 17) and checks whether it gets an address mask reply (ICMP Type 18). This scan can be enabled with the option -PM. In an attempt to discover live hosts using ICMP address mask queries, we run the command: `nmap -PM -sn MACHINE_IP/24`



<mark style="color:red;">**Nmap Host Discovery Using TCP and UDP**</mark>

<mark style="color:yellow;">We can send a packet with the SYN (Synchronize) flag set to a TCP port, 80 by default, and wait for a response.</mark> An open port should reply with a SYN/ACK (Acknowledge); a closed port would result in an RST (Reset). In this case, we only check whether we will get any response to infer whether the host is up.&#x20;

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption><p>TCP 3-way handshake</p></figcaption></figure>

f you want Nmap to use TCP SYN ping, you can do so via the option `-PS` followed by the port number, range, list, or a combination of them. For example, `-PS21` will target port 21, while `-PS21-25` will target ports 21, 22, 23, 24, and 25. Finally `-PS80,443,8080` will target the three ports 80, 443, and 8080.

We can use <mark style="color:yellow;">UDP to discover if the host is online</mark>. Contrary to TCP SYN ping, sending a UDP packet to an open port is not expected to lead to any reply. However, if we send a UDP packet to a closed UDP port, we expect to get an ICMP port unreachable packet; this indicates that the target system is up and available.

An example of a UDP scan command would be: `nmap -PU -sn MACHINE_IP/24`



<mark style="color:yellow;">Masscan</mark> uses a similar approach to discover the available systems. However, to finish its network scan quickly, Masscan is quite aggressive with the rate of packets it generates. The syntax is quite similar: -p can be followed by a port number, list, or range. Consider the following examples:

```
masscan MACHINE_IP/24 -p443
masscan MACHINE_IP/24 -p80,443
masscan MACHINE_IP/24 -p22-25
masscan MACHINE_IP/24 ‐‐top-ports 100
```



<mark style="color:red;">**Using Reverse DNS Lookup**</mark>

Nmap’s default behaviour is to use reverse-DNS online hosts. Because the hostnames can reveal a lot, this can be a helpful step. However, if you don’t want to send such DNS queries, you use `-n` to skip this step.

By default, Nmap will look up online hosts; however, you can use the option `-R` to query the DNS server even for offline hosts. If you want to use a specific DNS server, you can add the --dns-servers DNS\_SERVER option.



<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>



## <mark style="color:blue;">Nmap Basic Port Scans</mark>

<mark style="color:red;">**TCP and UDP Ports**</mark>

<mark style="color:red;">**I**</mark>n the same sense that an IP address specifies a host on a network among many others, a TCP port or UDP port is used to identify a network service running on that host. A server provides the network service, and it adheres to a specific network protocol. Examples include providing time, responding to DNS queries, and serving web pages. A port is usually linked to a service using that specific port number. For instance, an HTTP server would bind to TCP port 80 by default; moreover, if the HTTP server supports SSL/TLS, it would listen on TCP port 443. (TCP ports 80 and 443 are the default ports for HTTP and HTTPS; however, the webserver administrator might choose other port numbers if necessary.) Furthermore, no more than one service can listen on any TCP or UDP port (on the same IP address).





Nmap considers the following six states:

* Open: indicates that a service is listening on the specified port.&#x20;
* Closed: indicates that no service is listening on the specified port, although the port is accessible. By accessible, we mean that it is reachable and is not blocked by a firewall or other security appliances/programs.
* Filtered: means that Nmap cannot determine if the port is open or closed because the port is not accessible. This state is usually due to a firewall preventing Nmap from reaching that port. Nmap’s packets may be blocked from reaching the port; alternatively, the responses are blocked from reaching Nmap’s host.&#x20;
* Unfiltered: means that Nmap cannot determine if the port is open or closed, although the port is accessible. This state is encountered when using an ACK scan -sA.
* Open|Filtered: This means that Nmap cannot determine whether the port is open or filtered.&#x20;
* Closed|Filtered: This means that Nmap cannot decide whether a port is closed or filtered.



<mark style="color:red;">**TCP Flags**</mark>

Below is a table showing the contents of a TCP header. In the first row, we have the source TCP port number and the destination port number. We can see that the port number is allocated 16 bits (2 bytes). In the second and third rows, we have the sequence number and the acknowledgement number. Each row has 32 bits (4 bytes) allocated, with six rows total, making up 24 bytes.

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>



In particular, we need to focus on the flags that Nmap can set or unset. We have highlighted the TCP flags in red. Setting a flag bit means setting its value to 1. From left to right, the TCP header flags are:

* URG: Urgent flag indicates that the urgent pointer filed is significant. The urgent pointer indicates that the incoming data is urgent, and that a TCP segment with the URG flag set is processed immediately without consideration of having to wait on previously sent TCP segments.&#x20;
* ACK: Acknowledgement flag indicates that the acknowledgement number is significant. It is used to acknowledge the receipt of a TCP segment.&#x20;
* PSH: Push flag asking TCP to pass the data to the application promptly.&#x20;
* RST: Reset flag is used to reset the connection. Another device, such as a firewall, might send it to tear down a TCP connection. This flag is also used when data is sent to a host and there is no service on the receiving end to answer.
* SYN: Synchronize flag is used to initiate a TCP 3-way handshake and synchronize sequence numbers with the other host. The sequence number should be set randomly during TCP connection establishment.
* FIN: The sender has no more data to send.

<mark style="color:red;">****</mark>

<mark style="color:red;">**TCP Connect Scans**</mark>

TCP connect scan works by completing the TCP 3-way handshake. In standard TCP connection establishment, the client sends a TCP packet with SYN flag set, and the server responds with SYN/ACK if the port is open; finally, the client completes the 3-way handshake by sending an ACK.

It is important to note that if you are not a privileged user (root or sudoer), a TCP connect scan is the only possible option to discover open TCP ports.

Example: `nmap -sT MACHINE_IP`

<mark style="color:red;">**TCP SYN Scans**</mark>

Unprivileged users are limited to connect scan. However, the default scan mode is SYN scan, and it requires a privileged (root or sudoer) user to run it. SYN scan does not need to complete the TCP 3-way handshake; instead, it tears down the connection once it receives a response from the server. Because we didn’t establish a TCP connection, this decreases the chances of the scan being logged. We can select this scan type by using the -sS option.

Example: `nmap -sS MACHINE_IP`

<mark style="color:red;">****</mark>

<mark style="color:red;">**UDP Scans**</mark>

UDP is a connectionless protocol, and hence it does not require any handshake for connection establishment. We cannot guarantee that a service listening on a UDP port would respond to our packets. However, if a UDP packet is sent to a closed port, an ICMP port unreachable error (type 3, code 3) is returned. You can select UDP scan using the -sU option; moreover, you can combine it with another TCP scan.

Example:&#x20;

`nmap -sU MACHINE_ID`  is a generic UDP scan

`nmap -sU -F -v MACHINE_ID` is a more advanced UDP scan that uses the -F (fast) option and the -v (verbose) option.

<mark style="color:red;">****</mark>

<mark style="color:red;">**Fine-Tuning Scope and Performance**</mark>

* port list: -p22,80,443 will scan ports 22, 80 and 443.&#x20;
* port range: -p1-1023 will scan all ports between 1 and 1023 inclusive, while -p20-25 will scan ports between 20 and 25 inclusive.

You can request the scan of all ports by using `-p-`, which will scan all 65535 ports. If you want to scan the most common 100 ports, add `-F`. Using `--top-ports 10` will check the ten most common ports.



You can control the scan timing using `-T<0-5>`. `-T0` is the slowest (paranoid), while `-T5` is the fastest. According to Nmap manual page, there are six templates:

```
paranoid (0)
sneaky (1)
polite (2)
normal (3)
aggressive (4)
insane (5)
```

To avoid IDS alerts, you might consider `-T0` or `-T1`. For instance, `-T0` scans one port at a time and waits 5 minutes between sending each probe, so you can guess how long scanning one target would take to finish. If you don’t specify any timing, Nmap uses normal `-T3`. Note that `-T5` is the most aggressive in terms of speed; however, this can affect the accuracy of the scan results due to the increased likelihood of packet loss. <mark style="color:yellow;">Note that</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`-T4`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">is often used during CTFs and when learning to scan on practice targets, whereas</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`-T1`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">is often used during real engagements where stealth is more important.</mark>

Alternatively, you can choose to control the packet rate using --min-rate and --max-rate . For example, `--max-rate 10` or `--max-rate=10` ensures that your scanner is not sending more than ten packets per second.

Moreover, you can control probing parallelization using `--min-parallelism` and `--max-parallelism` . Nmap probes the targets to discover which hosts are live and which ports are open; probing parallelization specifies the number of such probes that can be run in parallel. For instance, `--min-parallelism=512` pushes Nmap to maintain at least 512 probes in parallel; these 512 probes are related to host discovery and open ports.

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

## <mark style="color:blue;">Nmap Advanced Port Scans</mark>







## <mark style="color:blue;">Nmap Post Port Scans</mark>







## <mark style="color:blue;">Protocols and Servers</mark>

<mark style="color:blue;"></mark>





## <mark style="color:blue;">Protocols and Servers 2</mark>

<mark style="color:blue;"></mark>

<mark style="color:blue;"></mark>

## <mark style="color:blue;">Net Sec Challenge</mark>





























